.. ARU (c) 2018 - 2025, Pavel Priluckiy, Vasiliy Stelmachenok and contributors

   ARU is licensed under a
   Creative Commons Attribution-ShareAlike 4.0 International License.

   You should have received a copy of the license along with this
   work. If not, see <https://creativecommons.org/licenses/by-sa/4.0/>.

.. _drivers:

************************
Настройка драйверов GPU
************************

.. index:: nvidia, tweaks, driver, settings, performance
.. _nvidia-settings:

====================================
Настройка закрытого драйвера NVIDIA
====================================

Драйвер NVIDIA - одно из самых болезненных мест с которым сталкиваются
пользователи при переходе на Linux. В данном разделе мы рассмотрим как
минимизировать количество испытываемой головной боли если вы являетесь
несчастным обладателем видеокарты NVIDIA под Linux.

.. index:: nvidia, xorg, tearing
.. _bad-nvidia-tips:

-------------------------------------------
Распространенные мифы о настройке драйвера
-------------------------------------------

Но прежде чем перейти к исправлению насущных проблем, поговорим о том,
чего делать определенно не стоит, то есть о различных вредных советах,
которые раньше могли иметь смысл, но сейчас уже нет.

Во-первых, автор категорически не рекомендует выполнять настройку
ваших мониторов и генерацию конфига ``xorg.conf`` в целом через
nvidia-settings или nvidia-xconfig как советовалось делать ранее. В
первую очередь потому, что это просто не нужно, так как современные
версии графического сервера Xorg сами выполняют автонастройку и
определение рабочих мониторов, кроме того большинство рабочих
окружений (DE) в своих настройках уже позволяют вам выставить
требуемую частоту обновления нескольких мониторов и их компановку,
перекрывая при этом все изменения сделанные в файле ``xorg.conf``,
который статичен и не может подстраиваться под изменения вашей
конфигурации. Например, подключение второго монитора на лету вызовет
проблемы, так как он не указан в ``xorg.conf``, а автоопределение при
наличии конфигурационного файла перестает работать. Вдобавок,
программа nvidia-settings также является крайне ограниченной в
конфигурациях с гибридной графикой (PRIME) или при использовании
сессий на базе протокола Wayland.

Больше подробностей о проблемах которые могут возникнуть при
использовании nvidia-settings в качестве конфигуратора для Xorg можно
прочитать здесь:

https://unix.stackexchange.com/questions/697517/how-to-correlate-xorg-conf-config-for-nvidia-gpu-with-xrandr-detected-screens/697553#697553

Автор так же рекомендует полностью отказаться от использования
морально устаревшей опции для ``xorg.conf`` как "Force composition
pipeline", так как современных композиторов, поставляемых вместе с
такими рабочими окружениями как GNOME/KDE/Cinnamon/Xfce и т.д.,
полностью достаточно чтобы предотвратить так называемую проблему
тиринга (разрывов экрана). К тому же "Force composition Pipeline"
имеет побочный эффект, создавая сильные задержки отклика, так
называемый input lag. И вызывает проблемы при работе расширения Vulkan
VK_KHR_present_wait, которое требуется для запуска многих игр при
использовании VKD3D-Proton. Подробнее смотрите здесь:
https://github.com/ValveSoftware/Proton/issues/6869.

Если же вы являетесь пользователем тайлинговых оконных менеджеров
(WM), где нет удобных средств настройки из коробки, то автор
рекомендует вам использовать такие средства как xrandr_ и композитор
picom_.

.. _xrandr: https://wiki.archlinux.org/title/Xrandr#Testing_configuration
.. _picom: https://wiki.archlinux.org/title/Picom

.. _fix_poor_cpu_performance:

----------------------------------------------------------------
Повышение производительности CPU на ноутбках с графикой NVIDIA
----------------------------------------------------------------

Обмен кадрами между iGPU и dGPU в следствии их копирования из VRAM в
ОЗУ может вызывать большую нагрузку на процессор, из-за чего
производительность самого CPU может сильно падать на ноутбуках с
гибридной графикой. Page Attribute Table (PAT) это более
оптимизированный метод управления памятью. Метод PAT создает таблицу
типов разделов по определенному адресу, отображенному в регистре, и
использует архитектуру памяти и набор инструкций более эффективно и
быстро. Для его активации в драйвере NVIDIA нужно указать параметр
``NVreg_UsePageAttributeTable=1``. Для этого как обычно создаем файл в
директории ``/etc/modprobe.d/`` или указываем через пробел в тот же
файл, что мы создавали ранее:

.. code-block:: shell
   :caption: ``sudo nano /etc/modprobe.d/nvidia-pat.conf``

   options nvidia NVreg_UsePageAttributeTable=1

См. также: https://bbs.archlinux.org/viewtopic.php?id=242007

.. index:: nvidia, laptopts, tdp, nvidia-powerd
.. _nvidia_powerd:

---------------------------------------------------
Повышение лимита TDP на ноутбках GPU Ampere и выше
---------------------------------------------------

К сожалению, в новых версиях драйверов NVIDIA невозможно зафиксировать
определенное значение TDP вручную через nvidia-smi. Но для
пользователей ноутбуков с GPU поколения Ampere (RTX 30xx) и выше, есть
обходной путь, который частично решает проблему путем незначительного
повышения лимита TDP. Для этого необходимо включить службу
``nvidia-powerd``, которая включает технологию Dynamic Boost::

   sudo systemctl enable nvidia-powerd

Например, на ноутбуке с 3050 Mobile это позволяет динамически повышать
(т.е. в зависимости от нагрузки на систему) лимит TDP видеокарты с 35
Вт до 40 Вт, без значительного изменения температуры, но с повышением
на 10 FPS в бенчмарке Furmark.

.. note:: Обратите внимание, что технология Dynamic Boost работает
   только тогда, когда ноутбук работает от сети и это также влияет на
   производительность процессора, изменяя максимальную частоту работы
   CPU.

.. index:: nvidia, environment, variables, latency
.. _nvidia-env-vars:

---------------------------------
Специальные переменные окружения
---------------------------------

Здесь речь пойдет о переменных окружения, которые влияют на поведение
драйвера при работе с приложениями которые используют API OpenGL или
Vulkan. Указать вы их можете либо в Lutris для конкретных игр, либо в
*"Параметрах Запуска"* игры в Steam (*"Свойства"* -> *"Параметры
запуска"*. После указания всех переменных обязательно добавьте в конце
"*%command%*", для того чтобы Steam понимал, что вы указали именно
системные переменные окружения для запуска игры, а не параметры
специфичные для этой самой игры).

``__GL_THREADED_OPTIMIZATIONS=1`` **(По умолчанию выключено)** -
Активируем многопоточную обработку OpenGL. Используете выборочно для
нативных игр/приложений, ибо иногда может наоборот вызывать регрессию
производительности. Некоторые игры и вовсе могут не запускаться с
данной переменной (К примеру, некоторые нативно-запускаемые части
Metro).

``__GL_MaxFramesAllowed=1`` **(По умолчанию - 2)** - Задает тип буферизации
кадров драйвером. Можете указать значение *"3"* (Тройная буферизация) для
большего количества FPS и улучшения производительности в приложениях/играх с
VSync. Мы рекомендуем задавать вовсе *"1"* (т.е. не использовать буферизацию,
подавать кадры так как они есть). Это может заметно уменьшить значение FPS в
играх, но взамен вы получите лучшие задержки отрисовки и реальный физический
отклик, т.к. кадр будет отображаться вам сразу на экран без лишних этапов его
обработки.

``__GL_YIELD="USLEEP"`` **(По умолчанию без значения)** - Довольно специфичный
параметр, *"USLEEP"* - снижает нагрузку на CPU и некоторым образом помогает в
борьбе с тирингом, а *"NOTHING"* дает больше FPS при этом увеличивая нагрузку
на процессор.

``__GL_SHADER_DISK_CACHE_SKIP_CLEANUP=1`` **(По умолчанию 0)** -
отключает ограничение кэша шейдеров OpenGL/Vulkan (по умолчанию
располагается по пути ``~/.cache/nvidia``). Рекомендуется для
современных нативных игр и DXVK 2.0+, где размер кэша может достигать
более гигабайта.

``__GL_SYNC_DISPLAY_DEVICE`` - указывает монитор с частотой которого
драйвер NVIDIA будет осуществлять синхронизацию. Это нужно для
конфигураций с двумя и более мониторами для предотвращения заиканий на
дисплеях с высокой частотой обновления на некоторых композиторах
(например Muffin). Представим, что у вас есть два дисплея, один 144
Гц, другой 60. В переменную следует указать видеовыход, в который
подключен монитор с наибольшей частотой обновления. Чтобы определить
какой монитор, в какой выход подключен можно использовать утилиту
``xrandr``. Данную переменную имеет смысл указывать глобально, то есть
в файле ``/etc/environment``.

.. code-block:: shell
   :caption: ``sudo nano /etc/environment``

    __GL_SYNC_DISPLAY_DEVICE=HDMI-0 # Это пример, указывайте свое имя выхода

.. index:: modules, mkinitcpio, initramfs
.. _important-modules:

--------------------------------------------
Добавление драйверов GPU в образы initramfs
--------------------------------------------

Иногда может понадобиться добавить модули для ядра в начальный
загрузочный образ (initramfs), который содержит в себе всё необходимое
для правильной загрузки ядра, включая необходимые драйверы и программы
для монтирования корневого раздела. Добавление модулей в initramfs
позволяет избежать некоторых проблем, когда загрузка модулей
происходит позже, чем когда они уже фактически нужны для
использования. Так происходит из-за параллельной загрузки сервисов
(юнитов) в systemd. Например, при использовании графического менеджера
входа в систему как SDDM, модули драйвера Nvidia могут быть загружены
позже, чем будет запущен сам сервис SDDM. Из-за этого пользователь
ловит так называемый "Чёрный экран".

За генерацию загрузочных образов могут отвечать различные программы,
но в Arch Linux по умолчанию для этого используется ``mkinitcpio``.
Чтобы добавить необходимые модули нужно создать новый файл со
следующим содержанием:

.. code-block:: shell
   :caption: ``sudo nano /etc/mkinitcpio.conf.d/10-modules.conf``

   MODULES+=(nvidia nvidia_modeset nvidia_uvm nvidia_drm)

Здесь мы добавляем модули драйвера Nvidia в загрузочный образ initramfs, но в
массив (ограничен скобками) вы можете прописать любые модули ядра, которые вы
считаете нужными для использования вовремя загрузки.

После добавления новых модулей обязательно нужно пересобрать уже
существующие образы initramfs::

  sudo mkinitcpio -P

.. warning:: Обратите внимание, что добавление большого количества
   модулей может сильно раздуть размер образа initramfs, поэтому перед
   этим убедитесь, что у вас имеется достаточно места в ``/boot`` разделе
   (если таковой имеется).

.. index:: mesa, amd
.. _mesa_tweaks:

=========================
Настройка драйверов Mesa
=========================

.. index:: amd, sam, bar
.. _force_amd_sam:

--------------------------------------------------------------------------
Форсирование использования AMD SAM *(Только для опытных пользователей)*.
--------------------------------------------------------------------------

AMD Smart Acess Memory (или Resizble Bar) — это технология которая
позволяет процессору получить доступ сразу ко всей видеопамяти GPU, а
не по блокам в 256 мегабайт, что приводит к задержкам ввода/вывода при
обмене между CPU и GPU. Несмотря на то, что данная технология заявлена
только для оборудования AMD и требует новейших комплектующих для
обеспечения своей работы, получить её работу можно и на гораздо более
старом оборудовании, например таком как AIT Radeon HD 7700.

.. warning:: Для включения данной технологии в настройках вашего BIOS
   (UEFI) должна быть включена опция *"Re-Size BAR Support"* и *"Above
   4G Decoding"*. Если таких параметров в вашем BIOS (UEFI) нет -
   скорее всего технология не поддерживается вашей материнской платой
   и не стоит даже пытаться её включить.

К сожалению, после недавнего обновления драйверов Mesa, поддержка SAM
была удалена из драйвера OpenGL - radeonsi, но вы по прежнему можете
заставить Mesa использовать SAM при работе в приложениях использующих
Vulkan.

Чтобы активировать SAM в Linux, нужно добавить переменные окружения:

.. code-block:: shell
   :caption: ``sudo nano /etc/environment``

   RADV_PERFTEST=sam # Только для Vulkan

.. warning:: Учтите, что в некоторых играх с vkd3d вам может
   понадобиться также экспортировать переменную
   ``VKD3D_CONFIG=no_upload_hvv`` для избежания регрессий
   производительности при использовании вместе с SAM.

   https://www.reddit.com/r/linux_gaming/comments/119hwmt/this_setting_may_help_vkd3d_games_that_have/

.. index:: amd, tweaks
.. _bug_solution_for_vega:

-------------------------------------------------------------------
Решение проблем работы графики Vega 11 (Спасибо @Vochatrak-az-ezm)
-------------------------------------------------------------------

На оборудовании со встроенным видеоядром Vega 11 может встретиться баг
драйвера, при котором возникают случайные зависания графики. Проблема
наиболее актуальна для *Ryzen 2XXXG* и чуть реже встречается на Ryzen
серии *3XXXG*, но потенциально имеет место быть и на более новых
видеоядрах Vega.

Решается через добавление следующих параметров ядра:

.. code-block:: shell
   :caption: ``sudo nano /etc/modprobe.d/90-amdgpu.conf``

   options amdgpu gttsize=8192 lockup_timeout=1000 gpu_recovery=1 noretry=0 ppfeaturemask=0xfffd3fff deep_color=1

На всякий случай можно дописать ещё одну переменную окружения:

.. code-block:: shell
   :caption: ``sudo nano /etc/environment``

   AMD_DEBUG=nodcc

Для подробностей можете ознакомиться со следующими темами:

https://www.linux.org.ru/forum/linux-hardware/16312119

https://www.linux.org.ru/forum/desktop/16257286

.. index:: intel, amd, mesa, tweaks
.. _multithreaded_opengl:

--------------------------------
Многопоточная OpenGL обработка
--------------------------------

У Mesa есть свой аналог переменной окружения
``__GL_THREADED_OPTIMIZATIONS=1``, так же предназначенный для
активирования многопоточной обработки OpenGL - ``mesa_glthread=true``.
В ряде игр и приложений это даёт сильное увеличение
производительности, но в некоторых либо нет прироста, либо вовсе не
может быть применено.

Чтобы включить его для всей системы нужно либо прописать переменную
окружения в файл ``/etc/environment``, либо используя adriconf_,
включив параметр во вкладке *"Performance"* -> *"Enable offloading GL
driver work to a separate thread"*

.. _adriconf: https://archlinux.org/packages/extra/x86_64/adriconf/

.. index:: intel, amd, mesa, tweaks, opencl, rusticl, davinci resolve
.. _mesa_rusticl_opencl:

--------------------------
Ускорение с помощью OpenCL
--------------------------

В 2021 году разработчики Mesa представили реализацию драйвера OpenCL, основанную
на языке Rust, под не замысловатым названием - *Rusticl* Данная реализация
призвана заменить старый драйвер *Clover*, и ныне совместима с OpenCL 3.0.

Для правильной работы аппаратного видео ускорения в таких приложениях
как Handbrake, Darktable и DaVinci Resolve вам может понадобиться
установить данный драйвер.

Чтобы установить данную реализацию драйвера, выполните данную команду в
терминале::

  sudo pacman -S opencl-rusticl-mesa

Теперь чтобы включить поддержку OpenCL на вашей видеокарте, укажите
данные значения в переменную ``RUSTICL_ENABLE`` в зависимости от
вашего производителя GPU:

.. tab-set::

   .. tab-item:: AMD

      .. code-block:: shell
         :caption: ``sudo nano /etc/environment``

         RUSTICL_ENABLE=radeonsi

      .. note:: Данная переменная будет работать на видеокартах с драйвером AMDGPU.

   .. tab-item:: Intel

       .. code-block:: shell
          :caption: ``sudo nano /etc/environment``

          RUSTICL_ENABLE=iris

       .. note:: Данный драйвер будет поддерживается на видеокартах, начиная с поколения Broadwell (Gen8) и новее.


.. index:: intel, mesa, vaapi, chromium
.. _intel_vaapi_driver:

---------------------------------------------------
Аппаратное ускорение видео на старых iGPU от Intel
---------------------------------------------------

К сожалению старые встраиваемые графические процессоры от Intel редко
удостаиваются вниманием со стороны разработчиков драйверов, в
следствии чего некоторые их возможности в Linux могут быть весьма
ограничены. Так с недавних пор Intel прекратила разработку старого
драйвера VAAPI, используемого для аппаратного ускорения видео в Linux,
в пользу нового драйвера intel-media-driver. Вместе с этим повысились
требования к минимально поддерживаемому поколению - теперь это
Broadwell (8-е поколение графики Intel), из-за чего пользователи
старых поколений, всё ещё имеющих возможность декодировать видео на
аппаратном уровне, остались без поддержки. В частности, начиная с
версии Chromium 116 аппаратное декодирование видео перестало работать
для поколений Haswell/Ivy Bridge/Sandy Bridge/Nehalem (Ironlake).

Однако относительно недавно появился форк драйвера Intel VAAPI для
старых поколений графики, так называемый IRQL форк, который решает
многие из проблем и позволяет получить правильно работающее аппаратное
видео ускорение в Chromium и основанных на нём браузерах. Если вы
являетесь обладателем встроенной графики Intel автор настоятельно
рекомендует установить вам данный вариант драйвера из AUR::

  git clone https://aur.archlinux.org/libva-intel-driver-irql
  cd libva-intel-driver-irql
  makepkg -sricCf

Обратите внимание, что на поколениях Ironlake и Sandybridge (Gen 5/Gen
6), для правильной работы аппаратного ускорения в Chromium требуется
использовать со следующие флаги для запуска и окружение на базе
Wayland:

.. code-block:: shell
 :caption: ``nano ~/.config/chromium-flags.conf``

 --enable-features=AcceleratedVideoDecodeLinuxZeroCopyGL,AcceleratedVideoDecodeLinuxGL
 --ozone-platform-hint=wayland

Без использования Wayland сессии вместе с указанными флагами для
Chromium будет наблюдатся чёрный (прозрачный) квадрат вместо видео.
Хотя на остальных поколениях графики Intel использование данных
параметров не обязательно, параметр
``AcceleratedVideoDecodeLinuxZeroCopyGL`` в окружениях на базе Wayland
активирует использование подсистемы dma-buf для прямого доступа
графического процессора к буферу для отрисовки видео, что может
заметно улучшить производительность.

.. vim:set textwidth=70:
