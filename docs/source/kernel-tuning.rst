.. ARU (c) 2018 - 2023, Pavel Priluckiy, Vasiliy Stelmachenok and contributors

   ARU is licensed under a
   Creative Commons Attribution-ShareAlike 4.0 International License.

   You should have received a copy of the license along with this
   work. If not, see <https://creativecommons.org/licenses/by-sa/4.0/>.

.. _kernel-tuning:

***************
Тюнинг ядра
***************

=========
Введение
=========

Как и любая другая программа, ядро имеет свои собственные настройки и
параметры, которые контролируют поведение определенных его частей. И
хотя настройки ядра Linux являются менее очевидными для понимания и
часто "скрыты" с глаз обычных пользователей, в данном разделе мы
рассмотрим различные настройки с ядра с целью улучшения
производительности и отзывчивости системы для домашнего ПК или
ноутбука, подобрав наиболее оптимальные значения в зависимости от
вашей конфигурации.

Как мы поймем далее, несмотря на то, что ядро Linux принято считать
монолитным, все настройки ядра относятся к определенным его
подсистемам, поэтому раздел будет разбит на систематические блоки
которые будут выполнять настройку конкретной его части, будь то
подсистема ввод/вывода или сети.

Стоит также отметить, что так как ядро является общей составляющей
всех дистрибутивов Linux, то почти вся информация которая будет
представлена в этом разделе применима не только к Arch Linux, но и ко
всем остальным. Учтите, что некоторые параметры зависят от вашей
версии ядра, которая, по понятным причинам, от одного дистрибутива к
другому может отличаться, поэтому обращайте внимания на пометки, где
указывается с какой версии появился тот или иной параметр. Узнать
версию используемого вами ядра можно через команду ``uname -r``.

-------
Зачем?
-------

Часто люди задаются вопросом, зачем пытаться лезть под капот, когда
"очевидно", что все уже сделано за тебя. С одной стороны это отчасти
правда, ядро Linux с каждой версией улучшается и "вылизывается"
тысячами разработчиками по всему миру, и, наверное, параметры о
которых речь пойдет далее уже имеют наиболее оптимальные значения. Но
к сожалению, это не совсем так. Во-первых, разработчики часто не могут
иметь представления, на каком конкретном железе будет работать ядро, в
следствии этого главным приоритетом при разработке является
совместимость и адаптивность ядра к как можно большему количеству
возможных задач и конфигурациям. Такой компромиссный подход к
разработке не всегда дает наилучшие результаты в чем-то конкретном, но
зато позволяет ядру Linux одинаково подходить для работы как на
серверах, роутерах, микроконтроллерах, так и простых ПК. Грубо говоря,
ядро Linux представляет собой швейцарский нож от мира IT, которым хоть
и можно так же порезать хлеб, но удобнее это делать обычным ножом.
Наша задача в данном разделе это как раз заточить ядро под конкретную
задачу, в нашем случае это интерактивное использование на домашнем
компьютере.

Если вы переживаете за стабильность вашей системы, то предварительно
можете сделать резервную копию, хотя на самом деле все параметры о
которых пойдет речь далее могут быть отключены в любой момент, простым
удалением файла настройки, поэтому даже при возникновении проблем со
стабильностью или регрессиями у вас не должно возникнуть проблем с
откатом к стоковым значениям.

--------------
Виды настроек
--------------

В ядре Linux параметры делятся на типы в зависимости от способа
установки их значения [#]_. Часть из них может быть установлена только на
этапе загрузки ядра, то есть в качестве опций командой строки [#]_.
Это то, что мы обычно пониманием под просто "параметрами ядра". Обычно
они указываются в настройках вашего загрузчика, будь то GRUB или
refind. В разделе :ref:`kernel-parameters` мы уже упоминали некоторые
из них и прописывали их в в конфигурационном файле загрузчика GRUB. К
этой же категории можно отнести параметры модулей ядра, значения к
которым передаются во время их загрузки. Правда они тоже могут быть
переданы как параметры ядра в конфиге вашего загрузчика в следующем
формате: ``module.parameter=value`` (например
``nvidia-drm.modeset=1``). То есть сначала указывается имя модуля
(драйвера), затем имя параметра и через равно передается значение.

~~~~~~~~~
sysctl
~~~~~~~~~

Другой тип, это параметры которые могут быть измены прямо во время
работы системы, что называется "на лету". Такие настройки представлены
в виде файлов на псевдофайловой системе procfs, в директории
``/proc/sys`` [#]_. procfs называется псевдофайловой потому, что
физически она не расположена на диске, а все файлы и директории
создаются самим ядром при запуске системы в оперативной памяти. По
этой причине у них отсутствует размер, и все они имеют чисто служебный
характер. В директории ``/proc/sys/`` каждая настройка - это отдельный
файл, куда мы должны просто передать значение в виде числа (часто 1 и
0 означают включить/выключить, но некоторые параметры также могут
принимать значения только из определенного диапазона и оно
подразумевает особый смысл). Все настройки объедены в директории,
которые характеризуют их отношение к чему-либо общему. Например, все
файлы в подкаталоге ``vm`` - это настройки для механизма виртуальной
памяти ядра [#]_ , включая настройки для подкачки, кэширования, и пр. В
``kernel`` - общие настройки ядра [#]_, а в ``net`` [#]_ - настройки сетевой
подсистемы, протоколов TCP и IP. Именно эти три категории мы и будем
рассматривать далее.

Конечно, процесс поиска всех файлов-настроек и установка их значений
средствами командой строки каждый раз весьма утомителен. Поэтому
разработчики создали специальную утилиту под названием ``sysctl``,
которая значительно упрощает данный процесс. Теперь нам не нужно
лазить каждый раз в ``/proc/sys/`` чтобы поменять значение параметра.
Вместо этого мы теперь пишем в терминале::

  sysctl -w sysctl kernel.sysrq=1

Это то же самое, что и данная команда, которая пишет значение напрямую в файл
из директории ``/proc/sys/``::

  echo "1" > /proc/sys/kernel/sysrq

Обратите внимание, что для изменения настроек всегда нужны права root
пользователя, поэтому перед каждой такой командой мы должны добавить ``sudo``::

  sudo sysctl -w kernel.sysrq=1

Другим преимуществом sysctl является то, что мы можем делать такие
изменения постоянными, просто прописав соответствующую строку в файл,
который находится в директории ``/etc/sysctl.d/``, например в
``/etc/sysctl.d/99-sysctl.conf``::

  kernel.sysrq = 1

Собственно именно добавлением таким строк мы и будем применять соответствующие настройки.

.. warning:: Настройки прописываемые в файле ``/etc/sysctl.conf`` не
   применяются начиная с версии 21x в systemd, поэтому
   прописывайте их именно в файлах, которые расположены в подкаталоге
   ``/etc/sysctl.d``. Имя файла не имеет значения.

~~~~~~~~~~~
tmpfiles.d
~~~~~~~~~~~

К сожалению, далеко не все настройки ядра представлены как параметры
для sysctl (``/proc/sys``), часть из них являются отладочными, и
расположены как файлы в другой псевдофайловой системе - sysfs, которая
в основном отвечает за представление информации об устройствах,
которыми управляет ядро. В директории в ``/sys/kernel`` представлены
ряд других полезных параметров, которые мы рассмотрим в рамках общей
темы. Чтобы выполнить установку значения в файлах, которые находятся
``/sys/kernel/``, мы используем такой инструмент как
systemd-tmpfiles.d [#]_. Он есть в любом дистрибутиве использующем systemd
(то есть в большей части дистрибутивов Linux) включая Arch. Его суть
состоит в создании и удалении временных файлов или установки значений
для уже существующих. Мы используем его для сохранения значений
настроек расположенных в ``/sys/kernel/``. Для этого по аналогии с
sysctl создадим файл в директории ``/etc/tmpfiles.d``, например
``/etc/tmpfiles.d/99-settings.conf``. Формат указания настроек будет
следующим::

  w /sys/kernel/mm/lru_gen/min_ttl_ms - - - - 300

Первый символ - это тип действия который мы хотим сделать. Мы будем
использовать только *w*, то есть писать в уже существующие файлы, а не
создавать новые. Затем указываем путь до файла-настройки, после четыре
прочерка, в них должны быть указаны права на файл которые мы хотим
изменить, но так как мы имеем дело со служебным файлом, то мы пишем
везде прочерки. В конце указываем значения для параметра.

Другими словами, везде, куда не дотянется sysctl, мы будем
использовать ``tmpfiles``.

~~~~~~
udev
~~~~~~

По сути первых двух инструментов уже достаточно, чтобы выполнить
полную настройку ядра, но мы используем ещё одну вещь - правила udev.
Udev [#]_ - менеджер для управления вашими устройствами, который
отслеживает их подключение/выключение, и предоставляет возможность
создавать так называемые "правила", которые вызываются каждый раз,
когда происходит определенной действие с тем или иным устройством.
Внутри этого правила можно указать, при каких действиях и для какого
конкретно устройства (условие для срабатывания) мы будем выполнять
определенную команду или устанавливать определенное значение. Это
позволит нам применять определенные настройки более гибко, то есть
подстраиваясь под железо и настройки которые у вас есть в системе.
Приведу пример, чтобы стало понятнее. Для разных типов носителей
подходит определенный планировщик ввода/вывода. Для обычных SSD -
``mq-deadline``, для HDD - ``bfq``. Правила udev позволяет нам при
подключении определенного типа устройства сразу выбирать нужный
планировщик и дополнительные параметры для него, даже если у вас в
системе есть и SSD, и HDD одновременно. Подробнее планировщики
ввода/вывода будут рассмотрены далее вместе с синтаксисом самих
правил.

=========================
Оптимизация ввода/вывода
=========================

Фууух, что-ж, надеюсь вы не устали от всего этого скучного бреда выше
и мы можем наконец-то переходить к сути. Начнем с оптимизации
ввода/вывода, то бишь к настройке свопа, различных кэшей и
планировщиков.

---------------------------
Настройка подкачки (Swap)
---------------------------

Прежде чем перейти непосредственно к настройке необходимо понять
принцип работы механизма подкачки в Linux (да-да, опять теория), так
как в этой теме ходит целая куча различных мифов, которые мы сейчас
разберем.

Итак, для начала чрезвычайно важно понимать, что ядро Linux разбивает
всю вашу память на маленькие "гранулы" - страницы памяти, как правило
по 4 КБ (для x86 архитектуры), не больше и не меньше. Это может
казаться странным, но если не вдаваться в технические подробности, то
такой подход позволяет ядру Linux проявлять достаточно большую
гибкость, так как данные страницы могут быть по разному обработаны в
зависимости от того, что в них записано. По этой причине страницы
памяти разбиваются на несколько типов. Сейчас мы не будем
рассматривать их все, но остановимся на самых главных:

- Файловая "подложка" или *файловые страницы*, это страницы в которых
  ядро "отображает", то есть представляет файловые данные считываемые
  с диска в виде страниц в памяти. Если какая-то программа открывает
  какой-то файл и читает из неё информацию, то ядро считывает данную
  информацию и сохраняет её в страничном кэше (page cache) [#]_, чтобы была
  возможность быстро обратиться к нему без повторного считывания с
  диска. Собственно, то, что вы видите в графе "Кэш" в любой программе
  аналоге системного монитора в Linux - и есть страничный кэш.

- Очевидно, что далеко не все данные которыми оперирует программа
  могут быть представлены в виде реальных файлов на диске, поэтому
  были созданы *анонимные страницы*, которые не ассоциированы с
  файлами. Программы запрашивают их у ядра во время выполнения для
  временных данных, которые нужны только на время их работы. Если вы
  разработчик, то вы навярняка сталкивались с такими понятиями "Куча"
  (Heap) и "стэк" (Stack). Так вот, ядро хранит данные из кучи и стэка
  именно в анонимных страницах памяти.

- Грязные страницы (dirty pages) - по сути это подвид файловых
  страниц, ключевое отличие которых состоит в том, что программы в них
  пишут какие-то изменения, а так как ядро кэширует все файлы во
  избежание излишней нагрузки на диск, то изменения которые программа
  делает в файле на самом деле происходят сначала в кэше, и только
  потом синхронизируются с реальным файлом на диске. Более подробно об
  этом виде страниц и процессе их синхронизации с диском мы поговорим
  в следующем разделе.

Вернемся к подкачке. Один из самых больших мифов связанных с подкачкой
состоит в том, что пользователи рассматривают её как некую
"дополнительную память", которую могут использовать программы в случае
нехватки реальной, то есть физической памяти. Это конечно же не так,
хотя бы потому, что процессор имеет доступ к оперированию только
данными которые находятся в оперативной памяти. В случае нехватки
памяти у ядра есть по сути всего один вариант - это освобождать
имеющуюся память от страниц, которые не используются в данный момент.
Да, память не берется из воздуха, и подкачка - это просто "чердак",
куда ядро скидывает все неиспользуемые вещи, дабы освободить место для
новых или часто используемых в данный момент страниц. При этом для
программы не меняется ровным счетом ничего, так как она все так же
может обратиться к странице, которая была вытеснена ядром в подкачку,
просто когда программа это сделает, ядро найдет эту страницу и обратно
загрузит её в оперативную память. Это ещё одно преимущество механизма
виртуальной памяти, повсеместно используемого ядром Linux.

Вопрос лишь в том, какие именно страницы нужно "вытеснить" из памяти.
На самом деле, это достаточно сложный вопрос. Прежде всего, конечно же
это будут именно анонимные страницы, так как файловые страницы и так
по сути ассоциированы с данными на диске, следовательно в случае чего
их так же можно повторно считать, и выгружать их в подкачку просто не
имеет никакого смысла. Но что если анонимных страниц много, а часть из
них реально используется программами? Какие из них тогда должны первым
делом попасть в подкачку? На данный и некоторые другие вопросы
отвечает специальный алгоритм в ядре Linux, называемый :abbr:`LRU
(Least recently used)` (а поныне и MGLRU). Если очень упрощенно, то
данный алгоритм ведет учет использования каждой страницы, то есть
количество обращений к ней, и на основе данной статистики
предполагает, какие из них меньше всего используются программами, и
следовательно какие из них можно безопасно выгрузить в подкачку.
Рядовые пользователи часто не до конца понимают, какие именно данные
расположены у них в подкачке. Теперь мы можем дать чёткий ответ: в
подкачке хранятся только неиспользуемые анонимные страницы памяти.

Мы разобрались с основополагающими понятиями, можем переходить к
настройке. Для настройки поведения подкачки используется параметр
sysctl ``vm.swappiness`` (значение по умолчанию 60). Вокруг него так
же ходит целый ряд заблуждений, что приводит к неправильным
умозаключениям. Итак, во-первых, ``vm.swappiness`` напрямую никак не
влияет на то, когда у вас начнет использоваться подкачка, то есть его
значение - это во все не процент свободной памяти начиная с которого
начинает использоваться своп. Ядро всегда начинает использоваться
подкачку только в ситуациях нехватки памяти (это, как правило, когда
занято 85-90% памяти), параметр ``vm.swappiness`` же влияет на
предпочтения ядра к вытеснению определенного типа страниц. Он
принимает значения от 0 до 200 (начиная с версии ядра 5.8 и выше, до
этого максимальным значением было 100). Для более наглядного
понимания, параметр ``vm.swappiness`` можно представить в виде весов,
где более низкие (ниже 100) значения означают склонность ядра к
вытеснению страниц из файлового кэша, а более высокие (больше 100) -
высвобождение анонимных страниц из памяти в подкачку. Значение же
``100`` - это своего рода баланс, при котором ядро будет в одинаковой
степени стараться вытеснять файловые и анонимные страницы.

Другим, крайне распространенным заблуждением является то, что более
низкие значения ``vm.swappiness`` уменьшают использование подкачки -
следовательно уменьшается нагрузка на ввод/вывод (диск), и что это
якобы улучшает отзывчивость системы. На деле это лишь на половину
правда, так как, да, ядро при низких значения старается откладывать
использование подкачки, хотя это и не значит, что она вообще не
используется, но важно понимать, что это происходит за счёт более
агрессивного вытеснения файловых страниц из страничного кэша - что
точно так же приводит к нагрузке на ввод/вывод. Во-вторых, нагрузка,
которую создают на диск подкачка часто слишком переоценена. Для
современных SSD накопителей переварить такую нагрузку не составит
труда, но даже если у вас HDD, то вам на помощь спешит zswap - ещё
один механизм, позволяющий значительно снизить нагрузку на диск.
Он представляет собой буфер, в который попадают анонимные страницы
которые на самом деле должны попасть в подкачку (то есть на диск) и
сжимаются внутри него, экономя тем самым драгоценную память (насколько
это возможно). Если пул страниц Zswap заполнится (по умолчанию он
равен 20%), то ядро выполнит выгрузку страниц из Zswap в подкачку.
Механизм Zswap используется во многих дистрибутивах Linux (В том числе
в Arch) по умолчанию, просто вы об этом могли не знать, и потому могли
думать, будто ядро "насилует" ваш диск при малейшем заполнении
подкачки.

Именно поэтому, автор рекомендует устанавливать значение в ``100``,
ибо в современных реалиях выкручивание параметра в низкие значения не
приведет к желаемому эффекту:

.. code-block:: shell
   :linenos:
   :caption: /etc/sysctl.d/90-sysctl.conf

   vm.swappiness = 100

Но что делать, если у вас и правда очень слабый носитель, и вы очень
хотите уменьшить нагрузку на диск? В этом случае лучшим решением
является использование ZRAM - вид подкачки, при котором все
неиспользуемые анонимные страницы не выгружаются на диск, а эффективно
сжимаются прямо в оперативной памяти, тем самым создавая определенную
экономию без использования диска. Конечно, стоит учитывать, что сжатие
происходит ресурсами процессора, и это накладывает определенные
накладные расходы. Об его установке мы уже говорили в разделе :ref:
`generic-system-acceleration`. Значение же ``vm.swappiness`` в таком
случае так же крайне рекомендуется установить в ``100``, так как более
низкие значения приведут к излишнему вытеснению из файлового кэша, а
анонимные страницы, которые потенциально могут быть сжаты, будут
вытесняться в последний момент.

==========
Источники
==========

Список источников используемых при составлении раздела:

.. [#] https://medium.com/@justaboutcloud/a-dive-deep-into-kernel-parameters-part-1-kernel-boot-parameters-139905e3432
.. [#] https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html
.. [#] https://www.kernel.org/doc/html/latest/admin-guide/sysctl/index.html
.. [#] https://www.kernel.org/doc/html/latest/admin-guide/sysctl/vm.html
.. [#] https://www.kernel.org/doc/html/latest/admin-guide/sysctl/kernel.html
.. [#] https://www.kernel.org/doc/html/latest/admin-guide/sysctl/net.html
.. [#] https://www.freedesktop.org/software/systemd/man/systemd-tmpfiles.html
.. [#] https://www.freedesktop.org/software/systemd/man/udev.html
.. [#] https://biriukov.dev/docs/page-cache/2-essential-page-cache-theory/

.. vim:set textwidth=70:
